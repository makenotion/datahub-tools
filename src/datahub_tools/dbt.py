from __future__ import annotations

import json
from dataclasses import dataclass
from functools import reduce
from operator import iconcat
from pathlib import Path
from typing import Any, Dict, Iterable, Set

import jmespath


@dataclass
class Dependency:
    left: str
    right: str

    def __str__(self):
        return f"{self.right} --> {self.left};"

    def reverse(self) -> Dependency:
        return Dependency(self.right, self.left)


@dataclass
class ModelDependencies:
    upstream: list[Dependency]
    downstream: list[Dependency]

    @classmethod
    def _compact(cls, deps: list[Dependency]) -> set[str]:
        return set(reduce(iconcat, [[x.left, x.right] for x in deps], []))

    def get_all_upstream(self) -> set[str]:
        return self._compact(self.upstream)

    def get_all_downstream(self) -> set[str]:
        return self._compact(self.downstream)


def get_dependency_tree(
    name: str, dependencies: dict[str, set[str]]
) -> list[Dependency]:
    deps = dependencies.get(name, set())
    assert isinstance(deps, set)
    out = []
    for dep in deps:
        out.append(Dependency(name, dep))
        out.extend(
            get_dependency_tree(
                name=dep,
                dependencies=dependencies,
            )
        )
    return out


def reverse_dependencies(dependencies: Dict[str, Set[str]]) -> Dict[str, Set[str]]:
    out: dict[str, set[str]] = {}
    for base, deps in dependencies.items():
        for dep in deps:
            if dep in out:
                out[dep].add(base)
            else:
                out[dep] = {base}

    return out


def extract_dbt_resources(
    manifest_file: str | Path, resource_type_filter: Iterable[str] | None = None
) -> Dict[str, Dict[str, Any]]:
    """
    Fetches the dbt resources from a generated manifest.json (e.g. dbt compile)
    :param manifest_file manifest file generated by dbt (e.g. manifest.json)
    :param resource_type_filter An optional resource type filter that will be applied
      before the resources are returned. For example ['snapshot', 'model']
    :return: A dictionary containing the snowflake table name (e.g. prep.core.calendar)
      and the associated dbt manifest dict (table metadata).
    """
    if isinstance(manifest_file, str):
        manifest_file = Path(manifest_file)
    with manifest_file.open() as f:
        manifest = json.load(f)
        manifest_nodes = manifest["nodes"]

    return {
        unique_id: data
        for unique_id, data in manifest_nodes.items()
        if (not resource_type_filter or data["resource_type"] in resource_type_filter)
    }


def get_dbt_dependencies(
    dbt_resources_by_unique_id: Dict[str, Dict[str, Any]]
) -> Dict[str, ModelDependencies]:
    """
    Returns a dictionary of each DBT resource along with its upstream and downstream
    dependencies.

    To use, generate a `manifest.json` with DBT (e.g. dbt compile), extract the
    resources with extract_dbt_resources, and then access each model's dependencies
    like so:

    ```
    model_deps = get_model_dependencies(manifest_file=...)
    resource = model_deps['my.resource.unique_id']
    upstream_deps = resource.get_all_upstream()
    downstream_deps = resource.get_all_downstream()
    ```

    Where each dependency is an instance of a Dependency, having a left and right:
    downstream_dependency.left --> 'my.resource.unique_id'
    downstream_dependency.right --> 'my.resource.downstream_dep_unique_id'

    :param dbt_resources_by_unique_id: Dict of DBT resources, from extract_dbt_resources
    """
    dependencies = {}
    for unique_id, dbt_resource in dbt_resources_by_unique_id.items():
        # the data lineage contains dupes
        data_lineage = jmespath.search("depends_on.nodes", dbt_resource) or []
        dependencies[unique_id] = set(data_lineage)

    dependency_tree = {}
    for unique_id, dbt_resource in dbt_resources_by_unique_id.items():
        upstream_deps = get_dependency_tree(name=unique_id, dependencies=dependencies)

        downstream_models = reverse_dependencies(dependencies=dependencies)
        downstream_deps = get_dependency_tree(
            name=unique_id, dependencies=downstream_models
        )
        downstream_deps = [x.reverse() for x in downstream_deps]

        dependency_tree[unique_id] = ModelDependencies(
            upstream=upstream_deps,
            downstream=downstream_deps,
        )

    return dependency_tree
